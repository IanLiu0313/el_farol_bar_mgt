# -*- coding: utf-8 -*-
"""Bunisess-ABM.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1q8TdDx92ePq33chcnJ1dhsIH87lEhfSv
"""

import random
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation
import os

is_Colab = False
if is_Colab:
    from google.colab import drive
    drive.mount('/content/drive', force_remount=True)
    os.chdir('/content/drive/MyDrive/Summer_24_Research/Business_Simulation_Project')
working_dir = os.getcwd()
print(working_dir)

working_dir

# Company class with properties
class Company:
    def __init__(self, initial_industry, scale, competitiveness, uncertainty):
        self.initial_industry = initial_industry
        self.scale = scale
        self.competitiveness = competitiveness
        self.uncertainty = uncertainty
        self.profitability = 0
        self.x, self.y = self.random_position_within_industry()

    def random_position_within_industry(self):
        radius = self.initial_industry['radius']
        x, y = self.initial_industry['x'], self.initial_industry['y']
        while True:
            rand_x = np.random.uniform(x - radius, x + radius)
            rand_y = np.random.uniform(y - radius, y + radius)
            if np.sqrt((rand_x - x) ** 2 + (rand_y - y) ** 2) <= radius:
                return rand_x, rand_y


# Define the overall market
market_size = 500

# Define the stages and their colors
stages = ['emergence', 'growth', 'maturity', 'decline']
stage_colors = {
    'emergence': 'blue',
    'growth': 'green',
    'maturity': 'orange',
    'decline': 'red'
}


# Function to update industries
def update_industries(industries, companies):
    for industry in industries:
        industry['age'] += 1
        total_age = industry['age']

        # Determine the current stage of the industry
        if total_age <= industry['stage_durations']['emergence']:
            industry['current_stage'] = 'emergence'
            industry['radius'] += industry['max_radius'] * 0.25 / industry['stage_durations']['emergence']
        elif total_age <= industry['stage_durations']['emergence'] + industry['stage_durations']['growth']:
            industry['current_stage'] = 'growth'
            industry['radius'] += industry['max_radius'] * 0.75 / industry['stage_durations']['growth']
        elif total_age <= sum(industry['stage_durations'].values()) - industry['stage_durations']['decline']:
            industry['current_stage'] = 'maturity'
        elif total_age <= industry['lifetime']:
            industry['current_stage'] = 'decline'
            industry['radius'] -= industry['max_radius'] / industry['stage_durations']['decline']

        # Ensure the radius does not fall below a minimum threshold
        if industry['radius'] < 1.1:
            industry['radius'] = 0

        # Calculate profitability for each company in the industry
        total_scale = sum(company.scale for company in companies if company.initial_industry == industry)
        max_area = industry['radius'] ** 2
        for company in companies:
            if company.initial_industry == industry:
                if total_scale <= max_area:
                    stage_profit = {'emergence': -0.15, 'growth': 0.10, 'maturity': 0.20, 'decline': 0.10}
                    company.profitability = stage_profit[industry['current_stage']]
                else:
                    stage_profit = {'emergence': -0.15, 'growth': 0.10, 'maturity': 0.20, 'decline': 0.10}
                    company.profitability = stage_profit[industry['current_stage']] * (max_area / total_scale)


# Function to update companies
def update_companies(companies, industries):
    for company in companies:
        industry = company.initial_industry
        company.scale += company.scale * company.competitiveness * company.profitability * (1 + company.uncertainty)
        if company.scale > industry['radius'] ** 2:
            company.scale = industry['radius'] ** 2


# Function to check if the new circle is at least 25 units away from existing circles
def is_far_enough(new_industry, industries, min_distance):
    for industry in industries:
        distance = np.sqrt((new_industry['x'] - industry['x']) ** 2 + (new_industry['y'] - industry['y']) ** 2)
        if distance < min_distance:
            return False
    return True


# Function to create a new industry
def create_new_industry(market_size, industries):
    initial_radius = 1
    max_radius = np.random.uniform(10, 50)  # Define a maximum radius
    min_boundary_distance = 20
    min_industry_distance = 25
    lifetime = int(np.random.exponential(100))
    while lifetime < 10 or lifetime > 3000:
        lifetime = int(np.random.exponential(50))
    stage_durations = {
        'emergence': int(0.10 * lifetime),
        'growth': int(0.30 * lifetime),
        'maturity': int(0.45 * lifetime),
        'decline': int(0.15 * lifetime)
    }

    # Ensure the industry is at least 20 units away from the boundaries and 25 units away from existing industries
    while True:
        x = np.random.uniform(min_boundary_distance, market_size - min_boundary_distance)
        y = np.random.uniform(min_boundary_distance, market_size - min_boundary_distance)
        new_industry = {
            'x': x,
            'y': y,
            'max_radius': max_radius,
            'radius': initial_radius,
            'lifetime': lifetime,
            'stage_durations': stage_durations,
            'current_stage': 'emergence',
            'age': 0
        }
        if is_far_enough(new_industry, industries, min_industry_distance):
            break
    return new_industry


# Function to create companies within an industry
def create_companies_for_industry(industry):
    companies = []
    num_companies = random.randint(1, 5)
    for _ in range(num_companies):
        scale = np.random.exponential(2)
        competitiveness = np.random.uniform(0.1, 1)
        uncertainty = np.random.uniform(-1, 1)
        company = Company(industry, scale, competitiveness, uncertainty)
        companies.append(company)
    return companies


# Initialize the initial industry and companies
industries = [create_new_industry(market_size, [])]
companies = create_companies_for_industry(industries[0])

fig, ax = plt.subplots(figsize=(10, 10))
ax.set_xlim(0, market_size)
ax.set_ylim(0, market_size)
ax.set_aspect('equal')
ax.set_facecolor('white')
ax.set_xticks([])
ax.set_yticks([])

# Add the title
ax.set_title('Overall Market')

industry_scat = ax.scatter([industry['x'] for industry in industries],
                           [industry['y'] for industry in industries],
                           s=[industry['radius'] ** 2 for industry in industries],
                           c=[stage_colors[industry['current_stage']] for industry in industries],
                           alpha=0.6)

# Placeholder for company scatter
company_scat = None


def animate(i):
    global company_scat
    # Small chance to add a new circle
    if np.random.rand() < 0.2:
        new_industry = create_new_industry(market_size, industries)
        industries.append(new_industry)
        companies.extend(create_companies_for_industry(new_industry))

    update_industries(industries, companies)
    update_companies(companies, industries)

    # Remove industries and companies if the industry disappears
    industries[:] = [industry for industry in industries if industry['radius'] > 0]
    companies[:] = [company for company in companies if company.initial_industry in industries]

    industry_scat.set_offsets([(industry['x'], industry['y']) for industry in industries])
    industry_scat.set_sizes([industry['radius'] ** 2 for industry in industries])
    industry_scat.set_color([stage_colors[industry['current_stage']] for industry in industries])

    # Update or create company scatter
    if company_scat:
        company_scat.remove()
    company_scat = ax.scatter([company.x for company in companies],
                              [company.y for company in companies],
                              s=[company.scale for company in companies],
                              c='black',
                              marker='s',
                              alpha=0.6)

    return industry_scat, company_scat


ani = animation.FuncAnimation(fig, animate, frames=1000, interval=100, blit=True)
ani.save("animation.gif", writer='pillow', fps=10)
plt.show()